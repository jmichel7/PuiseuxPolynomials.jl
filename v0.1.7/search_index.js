var documenterSearchIndex = {"docs":
[{"location":"#Puiseux-polynomials","page":"Home","title":"Puiseux polynomials","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for PuiseuxPolynomials","category":"page"},{"location":"#PuiseuxPolynomials.PuiseuxPolynomials","page":"Home","title":"PuiseuxPolynomials.PuiseuxPolynomials","text":"This  package implements  multivariate Puiseux  polynomials, that is linear combinations  with  coefficients  of  some  type T of monomials x₁^{a₁}… xₙ^{aₙ}  where  xᵢ  are  variables  and  aᵢ are exponents which can be arbitrary  rational  numbers.  When  the  aᵢ  are  integers  we  speak of \"multivariate Laurent polynomials\", and when the aᵢ are positive integers we speak of \"multivariate polynomials\" (or true polynomials).\n\nThis  package also implements  multivariate rational fractions, constructed as  the quotient of  two Laurent polynomials  (which are standardized to be the  quotient of  two true  polynomials and  to have  no common factor). In particular,  this package is a perfectly  usable (and hopefully quite good) implementation   of  multivariate  polynomials  and  multivariate  rational fractions, if that is what you are interested in.\n\nThe main use of Puiseux polynomials is that, if the elements of T form an algebraically closed field, Puisuex Polynomials are the ring of integers of the  algebraic  closure  of  the  the  multivariate  rational fractions. In particular  cyclotomic  Hecke  algebras  take  their  character  values and representations in them.\n\nThis  package depends only on the packages Reexport, LaurentPolynomials and ModuleEltss; the names defined by LaurentPolynomials are reexported by this package.\n\nOur  Puiseux polynomials have  the parametric type  Mvp{T,E} where T is the  type of the coefficients and E is the type of the exponents: E=Int for  Laurent  polynomials  and  E=Rational{Int}  for more general Puiseux polynomials.  When printing the  type of an  Mvp, only T  is printed if E==Int.  Rational  fractions  are  only  defined  if  the  numerator  and denominator  are true  polynomials; they  have type Frac{Mvp{T,Int}}.\n\nWe first look at how to make Puiseux polynomials. The macro @Mvp used  as @Mvp x₁,…,xₙ assigns (in the global scope of the current module) to  each Julia name xᵢ an Mvp representing an indeterminate suitable to build  multivariate polynomials or rational fractions.  This is thus a good start to a session with Mvps. Mvp(:x₁,…,:xₙ) creates the same Mvps as a list.\n\njulia> @Mvp x,y # creates the variables x,y\n\njulia> x,y=Mvp(:x,:y) # another way to do the same\n(x, y)\n\njulia> (x+y^-1)^3\nMvp{Int64}: x³+3x²y⁻¹+3xy⁻²+y⁻³\n\njulia> x+Mvp(:z)\nMvp{Int64}: x+z\n\njulia> x^(1//2)  # a Puiseux monomial\nMvp{Int64,Rational{Int64}}: x½\n\njulia> Mvp(3)  # convert a number to an Mvp with only a constant term\nMvp{Int64}: 3\n\nIt  is convenient  to create  Mvps using  variables like x,y above. The functions  repr or print  display an Mvp  in a form  that can be read back  in Julia –  this is also  the way an  Mvp is printed  in a context other than the repl, IJulia or pluto:\n\njulia> repr(3x*y^-2+4)\n\"Mvp{Int64, Int64}([:x=>1,:y=>-2]=>3,[]=>4)\"\n\nIt  is better not to use this  form casually, since the arguments must be normalized (sorted by key, and no duplicate key).\n\nOnly  monomials and one-term Mvps can  be raised to a non-integral power; the  Mvp with  one term  coefficient c  times the  monomial m  can be raised  to a fractional power of denominator d if and only if root(c,d) is defined (this is equivalent to c^(1//d) for floats);\n\njulia> (4x)^(1//2)\nMvp{Int64,Rational{Int64}}: 2x½\n\njulia> (2.0x)^(1//2)\nMvp{Float64,Rational{Int64}}: 1.4142135623730951x½\n\njulia> root(2.0x)\nMvp{Float64,Rational{Int64}}: 1.4142135623730951x½\n\nSome  other  packages  extend  root;  for  instance,  in my other package CylotomicNumbers I define square roots of rationals as cyclotomics, and I also have implemented arbitrary roots of roots of unity.\n\njulia> using CyclotomicNumbers\n\njulia> (2x)^(1//2)\nMvp{Cyc{Int64},Rational{Int64}}: √2x½\n\njulia> (E(3)*x)^(2//3)\nMvp{Cyc{Int64},Rational{Int64}}: ζ₉²x⅔\n\nThere  are various ways to take an Mvp apart. term below is the most   direct;   look   also   at   the   functions  coefficient, coefficients,        pairs,        monomials, variables and powers.\n\njulia> p=3x*y^-2+4\nMvp{Int64}: 3xy⁻²+4\n\njulia> term(p,1) # a term is a Pair monomial=>coefficient\nxy⁻² => 3\n\njulia> term(p,2) # the trivial monomial Monomial() prints as an empty string\n => 4\n\njulia> length(p) # the number of terms\n2\n\njulia> term.(p,1:length(p)) # same as pairs(p)\n2-element Vector{Pair{Monomial{Int64}, Int64}}:\n xy⁻² => 3\n      => 4\n\njulia> last(term(p,1)) # same as first(coefficients(p))\n3\n\njulia> m=first(term(p,1)) # same as first(monomials(p))\nMonomial{Int64}:xy⁻²\n\njulia> length(m) # how many variables in m\n2\n\njulia> Pair.(variables(m),powers(m)) # same as pairs(m)\n2-element Vector{Pair{Symbol, Int64}}:\n :x => 1\n :y => -2\n\njulia> degree(m,:x) # power of x in m\n1\n\njulia> degree(m,:y) # power of y in m\n-2\n\nThe valuation and degree of an Mvp can be inspected globally or variable by variable.\n\njulia> p\nMvp{Int64}: 3xy⁻²+4\n\njulia> variables(p)\n2-element Vector{Symbol}:\n :x\n :y\n\njulia> degree(p),degree(p,:x),degree(p,:y)\n(0, 1, 0)\n\njulia> valuation(p),valuation(p,:x),valuation(p,:y)\n(-1, 0, -2)\n\nThe  terms in an  Mvp are ordered  by a monomial  order (that is, a total order  on  monomials  such  that  x<y  implies  xz<yz for any monomials x,y,z).  The terms are in descending order, so that the first term is the highest. The default order is lex. The orders grlex and grevlex   are   also   implemented   (see  their  docstrings  and grobner_basis for how to use them).\n\nAn Mvp is a scalar if the valuation and degree are 0 (it has a single term  corresponding to  the one  monomial). The function scalar returns  the constant coefficient  if the Mvp  is a scalar, and nothing otherwise.\n\nUsual  arithmetic (+, -,  *, ^, /,  //, one, isone, zero, iszero,  ==)  works.  Elements  of  type  <:Number  are considered as scalars for scalar multiplication or division of the coefficients.\n\njulia> p\nMvp{Int64}: 3xy⁻²+4\n\njulia> p^2\nMvp{Int64}: 9x²y⁻⁴+24xy⁻²+16\n\njulia> p/2\nMvp{Float64}: 1.5xy⁻²+2.0\n\njulia> p//2\nMvp{Rational{Int64}}: (3//2)xy⁻²+2//1\n\nWhen  converting an Mvp to another type of Mvp one needs to specify the two  type parameters  (the type  of the  coefficients and  the type  of the exponents).\n\njulia> Mvp{Float64,Rational{Int}}(p)\nMvp{Float64,Rational{Int64}}: 3.0xy⁻²+4.0\n\nOne  can evaluate an Mvp,  setting the value of  some variables, by using the  function call syntax. \n\njulia> p=x+y\nMvp{Int64}: x+y\n\njulia> p(x=2)    # evaluate p at x=2\nMvp{Int64}: y+2\n\njulia> value(p,:x=>2) # there is also a more explicit [`value`](@ref) function.\nMvp{Int64}: y+2\n\njulia> p(x=2,y=x) # simultaneous evaluation\nMvp{Int64}: x+2\n\njulia> value(p,:x=>2,:y=>x)\nMvp{Int64}: x+2\n\nNote  that  an  Mvp  always  evaluates  to an Mvp, for consistency. You should  use scalar on the  result of giving values  to all variables in a Mvp to get a number.\n\njulia> p(x=1,y=2)\nMvp{Int64}: 3\n\njulia> scalar(p(x=1,y=2))\n3\n\njulia> v=(x^(1//2))(x=2.0)\nMvp{Float64,Rational{Int64}}: 1.4142135623730951\n\njulia> scalar(v)\n1.4142135623730951\n\nOne  can divide an Mvp by another  when the division is exact, or compute the gcd and lcm of two Mvps.\n\njulia> LinearAlgebra.exactdiv(x^2-y^2,x-y) # errors if the division is not exact\nMvp{Int64}: x+y\n\njulia> (x+y)/(2x^2)   # divide by a monomial\nMvp{Float64}: 0.5x⁻¹+0.5x⁻²y\n\njulia> (x+y)//(2x^2)\nMvp{Rational{Int64}}: (1//2)x⁻¹+(1//2)x⁻²y\n\njulia> (x+y)/(x-y)   # if the division is not exact one gets a rational fraction\nFrac{Mvp{Int64, Int64}}: (x+y)/(x-y)\n\nRaising  a non-monomial  Laurent polynomial  to a  negative power returns a rational   fraction.  Rational  fractions  are  normalized  such  that  the numerator  and denominators are true polynomials  prime to each other. They have  the  arithmetic  operations  +,  -  , *, /, //, ^, inv, one,  isone, zero, iszero (these  operations can operate between an Mvp or a Number and a Frac{<:Mvp}).\n\njulia> (x+1)^-2\nFrac{Mvp{Int64, Int64}}: 1/(x²+2x+1)\n\njulia> x+1/(y+1)\nFrac{Mvp{Int64, Int64}}: (xy+x+1)/(y+1)\n\njulia> 1/(y-1)-1/(y+1)\nFrac{Mvp{Int64, Int64}}: 2/(y²-1)\n\nOne  can evaluate a Frac,  setting the value of  some variables, by using the function call syntax or the value function:\n\njulia> ((x+y)/(x-y))(x=y+1)\nMvp{Float64}: 2.0y+1.0\n\njulia> value((x+y)/(x-y),:x=>y+1;Rational=true) # Rational=true says use //\nMvp{Int64}: 2y+1\n\nA  Frac can be dissected using numerator and denominator. Fracs and Mvps  are  scalars  for  broadcasting  and  can be sorted (have cmp and isless methods).\n\njulia> m=[x+y x-y;x+1 y+1]\n2×2 Matrix{Mvp{Int64, Int64}}:\n x+y  x-y\n x+1  y+1\n\njulia> n=inv(Frac.(m))\n2×2 Matrix{Frac{Mvp{Int64, Int64}}}:\n (-y-1)/(x²-2xy-y²-2y)  (x-y)/(x²-2xy-y²-2y)\n (x+1)/(x²-2xy-y²-2y)   (-x-y)/(x²-2xy-y²-2y)\n\njulia> lcm(denominator.(n))\nMvp{Int64}: x²-2xy-y²-2y\n\nFinally,   Mvps  have   methods  conj,   adjoint  which   operate  on coefficients,  a method derivative,  and methods positive_part, negative_part and bar (useful for Kazhdan-Lusztig theory).\n\njulia> @Mvp z\nMvp{Int64}: z\n\njulia> hessian(p,vars)=[derivative(derivative(p,x),y) for x in vars, y in vars]\nhessian (generic function with 1 method)\n\njulia> hessian(x^2*y^2*z^2,[:x,:y,:z])\n3×3 Matrix{Mvp{Int64, Int64}}:\n 2y²z²  4xyz²  4xy²z\n 4xyz²  2x²z²  4x²yz\n 4xy²z  4x²yz  2x²y²\n\njulia> jacobian(pols,vars)=[derivative(p,v) for p in pols, v in vars]\njacobian (generic function with 1 method)\n\njulia> jacobian([x,y,z],[:x,:y,:z])\n3×3 Matrix{Mvp{Int64, Int64}}:\n 1  0  0\n 0  1  0\n 0  0  1\n\njulia> p=(x+y^-1)^4\nMvp{Int64}: x⁴+4x³y⁻¹+6x²y⁻²+4xy⁻³+y⁻⁴\n\njulia> positive_part(p)\nMvp{Int64}: x⁴\n\njulia> negative_part(p)\nMvp{Int64}: y⁻⁴\n\njulia> bar(p)\nMvp{Int64}: y⁴+4x⁻¹y³+6x⁻²y²+4x⁻³y+x⁻⁴\n\nDespite  the degree of generality of our  polynomials, the speed is not too shabby.  For the Fateman test f(f+1)  where f=(1+x+y+z+t)^15, we take 3sec. According to the Nemo paper, Sagemath takes 10sec and Nemo takes 1.6sec.\n\n\n\n\n\n","category":"module"},{"location":"#PuiseuxPolynomials.Mvp","page":"Home","title":"PuiseuxPolynomials.Mvp","text":"Mvps are implemented as a list of pairs monomial=>coefficient sorted by the monomial order lex.\n\n\n\n\n\n","category":"type"},{"location":"#PuiseuxPolynomials.@Mvp-Tuple{Any}","page":"Home","title":"PuiseuxPolynomials.@Mvp","text":"@Mvp x,y\n\nis  equivalent to  (x,y)=Mvp(:x,:y) excepted  it creates  x,y in the global scope of the current module, since it uses eval.\n\n\n\n\n\n","category":"macro"},{"location":"#PuiseuxPolynomials.Mvp-Tuple{Symbol}","page":"Home","title":"PuiseuxPolynomials.Mvp","text":"Mvp(x::Symbol) creates the Mvp with one term of degree one and coefficient 1 with variable x\n\n\n\n\n\n","category":"method"},{"location":"#LaurentPolynomials.valuation","page":"Home","title":"LaurentPolynomials.valuation","text":"valuation(m::Mvp[,v::Symbol])\n\nThe valuation of an Mvp is the minimal degree of a monomial.\n\nWith  second argument a variable name, valuation returns the valuation of the polynomial in that variable.\n\njulia> @Mvp x,y; a=x^2+x*y\nMvp{Int64}: x²+xy\n\njulia> valuation(a), valuation(a,:y), valuation(a,:x)\n(2, 0, 1)\n\n\n\n\n\n","category":"function"},{"location":"#LaurentPolynomials.degree","page":"Home","title":"LaurentPolynomials.degree","text":"degree(m::Mvp[,v::Symbol])\n\nThe degree of a monomial is the sum of  the exponents of the variables. The degree of an Mvp is the largest degree of a monomial.\n\nWith  second argument a  variable name, degree  returns the degree of the polynomial in that variable.\n\njulia> a=x^2+x*y\nMvp{Int64}: x²+xy\n\njulia> degree(a), degree(a,:y), degree(a,:x)\n(2, 1, 2)\n\n\n\n\n\n","category":"function"},{"location":"#PuiseuxPolynomials.variables","page":"Home","title":"PuiseuxPolynomials.variables","text":"variables(a::Monomial) iterator on the variables of a (a sorted list of Symbols)\n\n\n\n\n\nvariables(p::Mvp)\n\nvariables(v::AbstractArray)\n\nreturns  the list of variables of p (resp. of all p in v) as a sorted list of Symbols.\n\njulia> @Mvp x,y,z\n\njulia> variables([z,[y+z],x])\n3-element Vector{Symbol}:\n :x\n :y\n :z\n\n\n\n\n\n","category":"function"},{"location":"#LaurentPolynomials.coefficients-Union{Tuple{N}, Tuple{T}, Tuple{Mvp{T, N}, Symbol}} where {T, N}","page":"Home","title":"LaurentPolynomials.coefficients","text":"coefficients(p::Mvp, var::Symbol) \n\nreturns  a Dict with keys the degree  in var and values the corresponding coefficient of p with respect to var.\n\njulia> p=(x+y+inv(y))^4\nMvp{Int64}: x⁴+4x³y+4x³y⁻¹+6x²y²+12x²+6x²y⁻²+4xy³+12xy+12xy⁻¹+4xy⁻³+y⁴+4y²+6+4y⁻²+y⁻⁴\n\njulia> coefficients(p,:x)\nDict{Int64, Mvp{Int64, Int64}} with 5 entries:\n  0 => y⁴+4y²+6+4y⁻²+y⁻⁴\n  4 => 1\n  2 => 6y²+12+6y⁻²\n  3 => 4y+4y⁻¹\n  1 => 4y³+12y+12y⁻¹+4y⁻³\n\njulia> coefficients(p,:y)\nDict{Int64, Mvp{Int64, Int64}} with 9 entries:\n  0  => x⁴+12x²+6\n  4  => 1\n  -1 => 4x³+12x\n  2  => 6x²+4\n  -3 => 4x\n  -2 => 6x²+4\n  -4 => 1\n  3  => 4x\n  1  => 4x³+12x\n\nThe  same  caveat  is  applicable  to  coefficients as to evaluating: the values  are always Mvps. To get a list of scalars for the coefficients of a  univariate polynomial represented as a Mvp, one should use scalar on the values of coefficients.\n\n\n\n\n\n","category":"method"},{"location":"#LaurentPolynomials.coefficients-Tuple{Mvp}","page":"Home","title":"LaurentPolynomials.coefficients","text":"coefficients(p::Mvp) \n\nis an efficient iterator over the coefficients of the monomials in p.\n\n\n\n\n\n","category":"method"},{"location":"#PuiseuxPolynomials.coefficient","page":"Home","title":"PuiseuxPolynomials.coefficient","text":"coefficient(p::Mvp,m::Monomial)\n\nThe coefficient of the polynomial p on the monomial m.\n\njulia> @Mvp x,y; p=(x-y)^3\nMvp{Int64}: x³-3x²y+3xy²-y³\n\njulia> coefficient(p,Monomial_(:x=>2,:y=>1)) # coefficient on x²y\n-3\n\njulia> coefficient(p,Monomial()) # constant coefficient\n0\n\n\n\n\n\ncoefficient(p::Mvp, var::Symbol, d) \n\nreturns  the coefficient of degree d in the variable var in the Mvp p.\n\njulia> @Mvp x,y; p=(x+y^(1//2)+1)^3\nMvp{Int64,Rational{Int64}}: x³+3x²y½+3x²+3xy+6xy½+3x+y³⁄₂+3y+3y½+1\n\njulia> coefficient(p,:y,1//2)\nMvp{Int64,Rational{Int64}}: 3x²+6x+3\n\njulia> coefficient(p,:x,1)\nMvp{Int64,Rational{Int64}}: 3y+6y½+3\n\n\n\n\n\n","category":"function"},{"location":"#PuiseuxPolynomials.Monomial","page":"Home","title":"PuiseuxPolynomials.Monomial","text":"Monomials are implemented as a ModuleElt, that is essentially as a list of  pairs :variable=>degree sorted in  the alphabetic order of variables. The degree can be Int or Rational{Int}.\n\n\n\n\n\n","category":"type"},{"location":"#PuiseuxPolynomials.monomials","page":"Home","title":"PuiseuxPolynomials.monomials","text":"monomials(p::Mvp) \n\nis an efficient iterator over the monomials of p.\n\n\n\n\n\n","category":"function"},{"location":"#PuiseuxPolynomials.powers","page":"Home","title":"PuiseuxPolynomials.powers","text":"powers(a::Monomial) iterator on the powers of variables in a\n\n\n\n\n\n","category":"function"},{"location":"#PuiseuxPolynomials.term","page":"Home","title":"PuiseuxPolynomials.term","text":"term(p::Mvp,i::Integer) The i-th term (a pair monomial=>coefficient) of p.\n\n\n\n\n\n","category":"function"},{"location":"#Base.pairs-Tuple{Monomial}","page":"Home","title":"Base.pairs","text":"pairs(a::Monomial) \n\nreturns the pairs :variable=>power in a.\n\n\n\n\n\n","category":"method"},{"location":"#Base.isless-Tuple{Monomial, Monomial}","page":"Home","title":"Base.isless","text":"isless(a::Monomial,b::Monomial)\n\nFor  our implementation of Mvps to  work, isless must define a monomial order (that is, for monomials m,a,b we have a<b => a*m<b*m). By default we  use the  \"lex\" order.\n\n\n\n\n\n","category":"method"},{"location":"#PuiseuxPolynomials.lex","page":"Home","title":"PuiseuxPolynomials.lex","text":"lex(a::Monomial, b::Monomial) The  \"lex\" order, where  a<b if the  first variable in  a/b occurs to a positive power.\n\n\n\n\n\n","category":"function"},{"location":"#PuiseuxPolynomials.grlex","page":"Home","title":"PuiseuxPolynomials.grlex","text":"grlex(a::Monomial, b::Monomial) The \"grlex\" order, where a<b̀ if degree(a)>degree(b) or the degrees are equal but lex(a,b).\n\n\n\n\n\n","category":"function"},{"location":"#PuiseuxPolynomials.grevlex","page":"Home","title":"PuiseuxPolynomials.grevlex","text":"grevlex(a::Monomial, b::Monomial) The  \"grevlex\" order, where a<b̀  if degree(a)>degree(b) or the degrees are equal but the last variable in a/b occurs to a negative power.\n\n\n\n\n\n","category":"function"},{"location":"#Base.pairs-Tuple{Mvp}","page":"Home","title":"Base.pairs","text":"pairs(p::Mvp) \n\nreturns the pairs monomial=>coefficient in p.\n\n\n\n\n\n","category":"method"},{"location":"#LaurentPolynomials.Pol-Union{Tuple{Mvp{T}}, Tuple{T}} where T","page":"Home","title":"LaurentPolynomials.Pol","text":"Pol(p::Mvp{T}) where T\n\nconverts the one-variable Mvp{T} p to a Pol{T}. It is an error if p has  more  than  one  variable,  or  this  variable appears to non-integral powers.\n\njulia> @Mvp x; @Pol q; Pol(x^2+x)\nPol{Int64}: q²+q\n\n\n\n\n\n","category":"method"},{"location":"#LaurentPolynomials.Pol-Union{Tuple{N}, Tuple{T}, Tuple{Mvp{T, N}, Symbol}} where {T, N}","page":"Home","title":"LaurentPolynomials.Pol","text":"Pol(p::Mvp,v::Symbol)\n\nreturns  a polynomial whose coefficients are  the coefficients of the Mvp p  with respect to the variable v  (as Mvps). The variable v should appear only with integral powers in p.\n\njulia> p=(x+y^(1//2))^3\nMvp{Int64,Rational{Int64}}: x³+3x²y½+3xy+y³⁄₂\n\njulia> Pol(:q); Pol(p,:x)\nPol{Mvp{Int64, Rational{Int64}}}: q³+3y½q²+3yq+y³⁄₂\n\nThis  can be used for instance to  compute the discriminant of a polynomial with respect to one of its variables:\n\njulia> p=x+y^2+x^3+y^3\nMvp{Int64}: x³+x+y³+y²\n\njulia> discriminant(Pol(p,:x))\nMvp{Int64}: 27y⁶+54y⁵+27y⁴+4\n\n\n\n\n\n","category":"method"},{"location":"#PuiseuxPolynomials.Mvp-Tuple{Pol}","page":"Home","title":"PuiseuxPolynomials.Mvp","text":"Mvp(p::Pol[,v]) converts p to  an  Mvp, with the same variable name   if v omitted or the variable name v.\n\njulia> @Pol q\nPol{Int64}: q\n\njulia> Mvp(q^2+q)\nMvp{Int64}: q²+q\n\njulia> Mvp(q^2+q,:x)\nMvp{Int64}: x²+x\n\n\n\n\n\n","category":"method"},{"location":"#PuiseuxPolynomials.value","page":"Home","title":"PuiseuxPolynomials.value","text":"`value(p::Mvp,:x₁=>v₁,:x₂=>v₂,...)`\n ̀(p::Mvp)(x₁=v₁,…,xₙ=vₙ)`\n\nreturns  the value of  p when doing  the simultaneous substitution of the variable :x1 by v1, of x2 by v2, …\n\njulia> p=-2+7x^5*inv(y)\nMvp{Int64}: 7x⁵y⁻¹-2\n\njulia> p(x=2)\nMvp{Int64}: -2+224y⁻¹\n\njulia> p(y=1)\nMvp{Int64}: 7x⁵-2\n\njulia> p(x=2,y=1)\nMvp{Int64}: 222\n\nOne should pay attention to the fact that the last value is not an integer, but  a constant Mvp (for consistency).  See the function scalar for how to convert such constants to their base ring.\n\njulia> p(x=y)\nMvp{Int64}: 7y⁴-2\n\njulia> p(x=y,y=x)\nMvp{Int64}: -2+7x⁻¹y⁵\n\nEvaluating an Mvp which is a Puiseux polynomial may cause calls to root\n\njulia> p=x^(1//2)*y^(1//3)\nMvp{Int64,Rational{Int64}}: x½y⅓\n\njulia> p(;x=y)\nMvp{Int64,Rational{Int64}}: y⅚\n\njulia> p(;x=4)\nMvp{Int64,Rational{Int64}}: 2y⅓\n\njulia> p(;y=2.0)\nMvp{Float64,Rational{Int64}}: 1.2599210498948732x½\n\n\n\n\n\n","category":"function"},{"location":"#Base.conj","page":"Home","title":"Base.conj","text":"conj(p::Mvp) acts on the coefficients of p\n\njulia> @Mvp x;conj(im*x+1)\nMvp{Complex{Int64}}: (0 - 1im)x+1 + 0im\n\n\n\n\n\n","category":"function"},{"location":"#LaurentPolynomials.derivative","page":"Home","title":"LaurentPolynomials.derivative","text":"The  function 'derivative(p,v₁,…,vₙ)' returns the  derivative of 'p' with  respect to  the variable given by the symbol 'v₁', then v₂, ...\n\njulia> @Mvp x,y;p=7x^5*y^-1-2\nMvp{Int64}: 7x⁵y⁻¹-2\n\njulia> derivative(p,:x)\nMvp{Int64}: 35x⁴y⁻¹\n\njulia> derivative(p,:y)\nMvp{Int64}: -7x⁵y⁻²\n\njulia> derivative(p,:x,:y)\nMvp{Int64}: -35x⁴y⁻²\n\njulia> p=x^(1//2)*y^(1//3)\nMvp{Int64,Rational{Int64}}: x½y⅓\n\njulia> derivative(p,:x)\nMvp{Rational{Int64},Rational{Int64}}: (1//2)x⁻½y⅓\n\njulia> derivative(p,:y)\nMvp{Rational{Int64},Rational{Int64}}: (1//3)x½y⁻⅔\n\njulia> derivative(p,:z)\nMvp{Rational{Int64},Rational{Int64}}: 0\n\n\n\n\n\n","category":"function"},{"location":"#PuiseuxPolynomials.laurent_denominator","page":"Home","title":"PuiseuxPolynomials.laurent_denominator","text":"laurent_denominator(p1,p2,…)\n\nreturns  the unique  monomial m  of minimal  degree in each variable such that  for all  the Laurent  polynomials p1,p2,…  the product m*pᵢ has a positive degree in each variable.\n\njulia> laurent_denominator(x^-1,y^-2+x^4)\nMonomial{Int64}:xy²\n\n\n\n\n\n","category":"function"},{"location":"#Base.gcd-Tuple{Mvp, Mvp}","page":"Home","title":"Base.gcd","text":"gcd(p::Mvp,  q::Mvp)  computes  the  gcd  of  the  'Mvp' arguments. The arguments must be true polynomials.\n\njulia> gcd((x+y)^2,x^2-y^2)\nMvp{Int64}: x+y\n\n\n\n\n\n","category":"method"},{"location":"#Base.lcm-Tuple{Mvp, Mvp}","page":"Home","title":"Base.lcm","text":"lcm(p1,p2,...)\n\nReturns  the Lcm  of the  Mvp arguments.  The arguments  must be  true polynomials.\n\njulia> lcm(x^2-y^2,(x+y)^2)\nMvp{Int64}: -x³-x²y+xy²+y³\n\n\n\n\n\n","category":"method"},{"location":"#LaurentPolynomials.scalar","page":"Home","title":"LaurentPolynomials.scalar","text":"scalar(p::Mvp)\n\nIf p is a scalar, return that scalar, otherwise return nothing.\n\njulia> p=Mvp(:x)+1\nMvp{Int64}: x+1\n\njulia> w=p(x=4)\nMvp{Int64}: 5\n\njulia> scalar(w)\n5\n\njulia> typeof(scalar(w))\nInt64\n\nif  p is an array, then apply scalar to its elements and return nothing if it contains any Mvp which is not a scalar.\n\n\n\n\n\n","category":"function"},{"location":"#Base.:^-Tuple{Mvp, AbstractMatrix}","page":"Home","title":"Base.:^","text":"Base.:^(p,m;vars=variables(p))\n\nImplements  the action of  a matrix on  Mvps. vars should  be a list of symbols   representing  variables.   The  polynomial   p  is  changed  by simultaneous  substitution in it of  vᵢ by (v×m)ᵢ where  v is the row vector  with entries  Mvp(vᵢ). If  vars is  omitted, it  is taken to be variables(p).\n\njulia> @Mvp x,y\n\njulia> (x+y)^[1 2;3 1]\nMvp{Int64}: 3x+4y\n\n\n\n\n\n","category":"method"},{"location":"#LaurentPolynomials.Frac-Tuple{T} where T<:Mvp","page":"Home","title":"LaurentPolynomials.Frac","text":"Frac(a::Mvp,b::Mvp;pol=false,prime=false)\n\nMvps  a and b are promoted to  same coefficient type, and checked for being  true polynomials  without common  monomial factor (unless pol=true asserts  that this  is already  the case)  and unless prime=true they are made prime to each other by dividing by their gcd.\n\n\n\n\n\n","category":"method"},{"location":"#PuiseuxPolynomials.grobner_basis","page":"Home","title":"PuiseuxPolynomials.grobner_basis","text":"grobner_basis(F;lt=lex)\n\ncomputes  a Gröbner basis  of the polynomial  ideal generated by the Mvps given  by the vector F. The keyword  lt describes the monomial order to use.\n\njulia> @Mvp x,y,z; F=[x^2+y^2+z^2-1,x^2-y+z^2,x-z]\n3-element Vector{Mvp{Int64, Int64}}:\n x²+y²+z²-1\n x²-y+z²\n x-z\n\njulia> grobner_basis(F)\n3-element Vector{Mvp{Rational{Int64}, Int64}}:\n (1//1)x+(-1//1)z\n (-1//1)y+(2//1)z²\n (4//1)z⁴+(2//1)z²-1//1\n\njulia> grobner_basis(F;lt=grlex)\n3-element Vector{Mvp{Rational{Int64}, Int64}}:\n (1//1)x+(-1//1)z\n (1//1)y²+(1//1)y-1//1\n (-1//1)y+(2//1)z²\n\njulia> grobner_basis(F;lt=grevlex)\n3-element Vector{Mvp{Rational{Int64}, Int64}}:\n (1//1)x+(-1//1)z\n (1//1)y²+(1//1)y-1//1\n (2//1)x²+(-1//1)y\n\nThere is no keyword to change the order of the variables. We suggest to use rename_variables for this purpose.\n\n\n\n\n\n","category":"function"},{"location":"#PuiseuxPolynomials.rename_variables","page":"Home","title":"PuiseuxPolynomials.rename_variables","text":"rename_variables(p,v) renames variables(p) to v\n\nrename_variables(p,l::Pair{Symbol,Symbol}...) renames the  variables in p as indicated by the pairs in l.\n\njulia> @Mvp x,y,z; p=x+y+z\nMvp{Int64}: x+y+z\n\njulia> rename_variables(p,Symbol.('A':'Z'))\nMvp{Int64}: A+B+C\n\njulia> rename_variables(p,[:U,:V])\nMvp{Int64}: U+V+z\n\njulia> rename_variables(p,:x=>:U,:z=>:V) # faster than p(;x=Mvp(:U),z=Mvp(:V))\nMvp{Int64}: U+V+y\n\n\n\n\n\n","category":"function"}]
}
